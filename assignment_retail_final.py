# -*- coding: utf-8 -*-
"""assignment-retail-final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y-FbCVqo6p-OwMea-2MXHNeZNwI1iudP

<img src="https://static.wincacademy.nl/logos/main-logo.png" height=200px style="height: 200px"/>

# Assignment: Retail

Congratulations! You've reached the final assignment for the course before the bonus modules. Here we'll ask you to work with a dataset from the Dutch *Centraal Bureau voor de Statistiek* (CBS, English: Statistics Netherlands). It contains monthly growth percentages for various branches of the retail sector. You'll be required to answer open questions as well as write code that handles the data and crunches numbers.

*Answer open questions as though you were writing a report. Answers that are too vague, too short or too sloppy will be rejected.*
"""

from google.colab import drive
drive.mount('/content/drive')

"""## 0. Load required modules

First, we need to load some modules that we're going to use. Do that in the next code cell. If you don't know yet which modules you'll use, just read on and come back here to import them later. **Don't forget to run the cell whenever you make an edit!**
"""

import csv
from datetime import datetime
import itertools
from tabulate import tabulate

"""## 1. Data Preparation
Now we need to load and parse the data. The data should be located in the same folder as this notebook (whether that's on Google Colab or your local machine). Make sure you have working file path from your notebook to the supplied `data.csv` file. Put an `x` in the checkbox below when you're ready.

- [x] *I have a working file path to the `data.csv` file.*

You are now ready to proceed with reading the data into your program.

### 1.1 Read the CSV

The data comes in the form of a `csv`-file. CSV stands for 'comma separated values'. Oddly enough it need not be the case that the values are *really* separated by commas. In this case, the **delimiter** - the character that separates the columns within a datapoint - is *not* a comma. It's up to you to inspect `data.csv` and find out what the delimiter is.

Once you know what the delimiter is, you can use Python's `csv` module to read each of the datapoints to a dictionary. Some tips:

- The module's name is `csv`.
- You can find its documentation [here](https://docs.python.org/3/library/csv.html)
- We suggest you use the `DictReader` class. There's an example on how to use `DictReader` in the linked documentation.
- Instead of printing the rows (like in the example), we suggest you store all the rows as `dict`s in a `list`.

**1. In the code cell below, write code that opens and reads the data. By the end of the cell, you should have a variable `data` that is a list of dictionaries that each contain a datapoint.**
"""

def data_dict():
    with open("/content/drive/MyDrive/retail-data.csv") as file:
        data = [{key: value for key, value in row.items()}
             for row in csv.DictReader(file, delimiter=";")]
    return data

retail_data = data_dict()
print(retail_data)

"""### 1.2 Parse and clean the data

You now have a list of dictionaries that each contain some data. But what data? Answer the following questions to become familiar with this dataset. It requires you to write and execute Python code (you can add code cells if you wish), and also search the web for terms you're not familiar with.

**2. What are the column names in this dataset, and what do they mean? Be specific.**

Columns are:
1. 'Bedrijfstakken/branches (SBI 2008)' -> De Standaard Bedrijfsindeling (SBI) is een hiÃ«rarchische indeling van economische activiteiten die het CBS onder meer gebruikt om bedrijfseenheden in te delen naar hun hoofdactiviteit.
2. 'Perioden' -> in welke periode vond de meting plaats?
3. 'Omzet ongecorrigeerd/Indexcijfers/Waarde (2015=100)' -> de ontwikkeling van de geldopbrengst van de omzet, tov 2015.
4. 'Omzet ongecorrigeerd/Indexcijfers/Volume (2015=100)' -> De ontwikkeling van de hoeveelheid verkochte goederen en diensten. De ontwikkeling is niet waargenomen, maar berekend. De hoeveelheid verkochte goederen en diensten in een bepaalde periode berekent het CBS door de waarde van de omzet te delen door de prijs.

Ongecorrigeerd -> Uitkomsten die niet gecorrigeerd zijn voor koopdag- en/of seizoeneffecten. 


**3. For each column, list what data type it should have (`str`, `int`, `float` or `datetime.date`).**

1. -> str
2. -> datetime.date
3. -> float
4. -> float
    
**4. In the code cell below, write code that changes the column names to something more convenient for writing readable code. Be sure to choose English, correct and meaningful names.**
"""

def new_column_names(retail_data):
    for retail_dict in retail_data:
        retail_dict['Industry'] = retail_dict.pop('Bedrijfstakken/branches (SBI 2008)')
        retail_dict["Periods"] = retail_dict.pop("Perioden")
        retail_dict["Index revenue"] = retail_dict.pop("Omzet ongecorrigeerd/Indexcijfers/Waarde (2015=100)")
        retail_dict["Index volume"] = retail_dict.pop("Omzet ongecorrigeerd/Indexcijfers/Volume (2015=100)")
    return retail_data

english_retail_data = (new_column_names(retail_data))
print(english_retail_data)

"""**5. In the code cell below, write code that casts all the data to the right type.**

Tips:
- If you overwite your data, running the casting operation you're about to implement more than once might result in errors. In that case you can opt not to reuse a variable or restart and rerun your notebook for every retry.
- The data is in Dutch. For some columns this does not matter, but for one in particular it makes parsing it a little bit harder. There is a way to handle this in a few lines of code. You'll need Python's `locale` module for this, as well as the special string `'nl_NL.UTF-8'`. If you're not sure how to use this information after searching the web for a while, it's OK to take the long way around and write custom code to handle the Dutch words.
- The parsing script is bound to run into errors. **Do not modify the data file on disk.** Carefully read the error, examine why it works on most values and crashes on some others, and apply a fix in your code! We'll give you some tips:
    - A handful of values in the `Perioden`-column might cause an error due to an unexpected character. You can safely ignore that character.
    - Handle missing numerical values by replacing them with `-1.`. Be sure to maintain the correct datatype for that column!
"""

def clean_data(english_retail_data):
    for retail_dict in english_retail_data:
        try: 
            new_revenue_string = retail_dict["Index revenue"].strip(' .')
            retail_dict["Index revenue"] = float(new_revenue_string)
        except Exception:
            retail_dict["Index revenue"] = -1.0
        try:
            new_volume_string = retail_dict["Index volume"].strip(' .')
            retail_dict["Index volume"] = float(new_volume_string)
        except Exception as e:
            retail_dict["Index volume"] = -1.0
        new_date_string = (retail_dict["Periods"]).strip(' *')
        retail_dict["Periods"] = new_date_string
    return english_retail_data    

print(clean_data(english_retail_data))

def translate_period(period_string):
    mapping = {
        "januari": "january",
        "februari": "february",
        "maart": "march",
        "mei": "may",
        "juni": "june",
        "juli": "july",
        "augustus": "august",
        "oktober": "october",
        "november": "november",
        "december": "december"
    }
    for k, v in mapping.items():
        period_string = period_string.replace(k, v)
    return period_string

def cast_date_time(english_retail_data):
    for retail_dict in english_retail_data:
        formated_date = datetime.strptime(translate_period(retail_dict["Periods"]), "%Y %B")
        retail_dict["Periods"] = formated_date
    return english_retail_data

print(cast_date_time(english_retail_data))

"""## 2. Data Exploration

You are now ready to explore the data.

**6. In the code cell below, print the following metadata. Format the printed text in a nice and tidy way. Put an `x` in the checkboxes when you've succeeded.**

- [x] **The number of datapoints in the dataset.**
- [x] **The number of unique branches of the retail sector the data covers.**
- [x] **The first month covered by the data.**
- [x] **The last month covered by the data.**
"""

#number of datapoints
print(f'Number of datapoints: {len(english_retail_data)}')

#number of unique branches
def unique_branches (english_retail_data):
    branche_list = []
    for retail_dict in english_retail_data:
        branche = retail_dict["Industry"]
        branche_list.append(branche)
    unique_branche_list = list(set(branche_list))  
    return unique_branche_list
print(f'Number of unique branches: {len(unique_branches(english_retail_data))}')

def sort_months(english_retail_data):
    month_list = []
    for retail_dict in english_retail_data:     
        month_list.append(retail_dict["Periods"])
    return sorted(month_list)

#first month covered by data
print(f'First month covered by data: {(min(sort_months(english_retail_data))).strftime("%Y-%m")}')

#last month covered by data
print(f'Last month covered by data: {(max(sort_months(english_retail_data))).strftime("%Y-%m")}')

"""**7. In the code cell below, extract the revenue numbers for the following two sectors and put them in a list named exactly as indicated. Also create a list that contains all the months in ascending order. Run the cell after it to see a plot of the numbers if you did it correctly.**

- [x] Months in ascending order $\Longrightarrow$ `months`
- [x] Clothing stores $\Longrightarrow$  `clothing_stores_revenue`
    - Tip: the Dutch word for *'clothing'* is *'kleding'*
- [x] Mail order companies and web shops $\Longrightarrow$ `mail_order_revenue`
    - Tip: the Dutch term for *'mail order companies'* is *'postorderbedrijven'*
"""

#months in ascending order
def sort_months(english_retail_data):
    month_list = []
    for retail_dict in english_retail_data:     
        month_list.append(retail_dict["Periods"])
    return sorted(set(month_list))
months = (sort_months(english_retail_data))
print(months)

#revenue 'kleding' branche
def clothing_stores_revenue (english_retail_data):
    clothing_stores_revenue_list = []
    for retail_dict in english_retail_data:
        if "kleding" in retail_dict["Industry"]:
            clothing_revenue = retail_dict["Index revenue"]
            clothing_stores_revenue_list.append(clothing_revenue)
    return clothing_stores_revenue_list

clothing_stores_revenue = (clothing_stores_revenue (english_retail_data))
print (clothing_stores_revenue)

#revenue 'Postorderbedrijven' branche
def mail_order_revenue (english_retail_data):
    mail_stores_revenue_list = []
    for retail_dict in english_retail_data:
        if "Postorderbedrijven" in retail_dict["Industry"]:
            mail_revenue = retail_dict["Index revenue"]
            mail_stores_revenue_list.append(mail_revenue)
    return mail_stores_revenue_list

mail_order_revenue = (mail_order_revenue (english_retail_data))
print (mail_order_revenue)

# Commented out IPython magic to ensure Python compatibility.
# Do not modify the code in this cell.
import matplotlib.pyplot as plt
# %matplotlib inline

try:
    fig, ax = plt.subplots(figsize=(16, 9))
    ax.plot(months, clothing_stores_revenue, label="Clothing stores' revenue")
    ax.plot(months, mail_order_revenue, label="Mail order companies' revenue")
    ax.set_xlabel('Date')
    ax.set_ylabel('Percent, 2015=100')
    ax.legend()
    plt.show()
except Exception as e:
    print('There was an error creating the plot.\n'
          'Check if your lists are correctly named and assembled.\n'
          "Here's your error, for your debugging pleasure.")
    raise e

"""**8. How do the two branches compare? Discuss any yearly cycles you observe, as well as long-term developments. Also explain why you think these patterns are there. Pretend you are writing this to your supervisor or a client who asked you to analyze this dataset.**

Voor de kleding branche zien we jaarlijks terugkerende pieken en dalen in de omzet. Mijn verwachting is dat dit te maken heeft met de aanschaf van kleding per seizoen: vlak voor het eind van een jaar zie je een piek (inkopen voor het feestdagen?), waarna er een dal terugkeert (even geen geld meer na de feestdagen). Halverwege het jaar lijkt er ook weer een piek terug te komen (kledinginkopen voor het zomerseizoen?).
Bij de post zijn er in eerste instantie minder duidelijke pieken/dalen door het jaar heen. Post was vroeger voornamelijk bestemd voor brieven en beperkt voor pakjes.

Door de jaren heen zie je een toename van de omzet van post. Er wordt meer verstuurt met post, en mijn verwachting is dat dit door het gebruik van online bestellingen komt. Door de jaren heen is online shoppen steeds populairder geworden.
Ook zie je dat er duidelijkere pieken ontstaan bij de post, en vooral rond het eind van het jaar. Net als bij de kleding is mijn verwachting dat dit te maken heeft met de feestdagen (Black Friday, Sinterklaas, Kerst etc), waar extra besteld (en dus bezorgd) wordt.

De kleding verkoop lijkt rond 2020 wat gedaald te zijn. Mijn verwachting is dat dit komt door Corona, waardoor winkels een tijd gesloten waren. Tegelijkertijd zie je bij de post een hele grote piek in 2020. Ook hier trek ik de vergelijking met Corona, waardoor men juist veel meer online is gaan bestellen (en dus versturen via post).

## 3. Computing With Data

### 3.1 Year Over Year Change

Let's take a closer look at these two branches of retail: clothing stores and mail order companies. A commonly used metric in business is the year-over-year revenue change. It is computed like so:

$$\text{YoY}_\text{month} = \frac{\text{Revenue}_\text{month}}{\text{Revenue}_\text{same month last year}} \times 100$$

Search the web for a longer explanation of this term if you'd like one.

**9. Why should we compare revenue for a particular month to the revenue of that same month, one year ago?**

Door de YoY vergelijking kun je meer inzicht krijgen in trends/speciale gebeurtenissen. Door op maandbasis te vergelijken, haal je de verschillen die ontstaan door seizoensverschillen weg, en kun je specifieker kijken wat de verschillen zijn van de ene maand, met die maand een jaar geleden. (denk bijvoorbeeld aan de veranderingen die we hierboven zagen in de maanden in 2020, die waarschijnlijk veroorzaakt werden door Corona).

**10. In the code cell below, compute the year-over-year revenue change for every month, for both branches of the retail sector, each in their own new list. Skip the first year (why?). Put an `x` in the checkboxes when you're ready. Run the next cell to see a new plot for your data.**

- [x] Clothing stores $\Longrightarrow$ `clothing_stores_yoy`
- [x] Mail order companies $\Longrightarrow$ `mail_order_yoy`
"""

#clothing_stores_yoy
def clothing_stores_yoy(english_retail_data):
    clothing_stores_yoy = []
    y = ((min(months)).year) + 1
    m = 1
    while y <= ((max(months)).year):
        while m < 13 and not (y == max(months).year and m > max(months).month):
            for retail_dict in english_retail_data:   
                date = datetime(year=(y), month=(m), day=1, hour=0, minute=0)
                if "kleding" in retail_dict["Industry"] and retail_dict["Periods"] == date:
                    clothing_revenue_month = retail_dict["Index revenue"] 
            for retail_dict in english_retail_data:
                date = datetime(year=(y-1), month=(m), day=1, hour=0, minute=0)
                if "kleding" in retail_dict["Industry"] and retail_dict["Periods"] == date:
                    clothing_revenue_month_lastyear = retail_dict["Index revenue"]
            clothes_onemonth_yoy = round(((clothing_revenue_month/clothing_revenue_month_lastyear)*100), 2)
            clothing_stores_yoy.append(clothes_onemonth_yoy)
            m = m + 1
        y = y + 1
        m = 1
    return clothing_stores_yoy
clothing_stores_yoy = (clothing_stores_yoy(english_retail_data))

#mail_order_yoy
def mail_order_yoy(english_retail_data):
    mail_order_yoy = []
    y = ((min(months)).year) + 1
    m = 1
    while y <= ((max(months)).year):
        while m < 13 and not (y == max(months).year and m > max(months).month):
            for retail_dict in english_retail_data:   
                date = datetime(year=(y), month=(m), day=1, hour=0, minute=0)
                if "Postorderbedrijven" in retail_dict["Industry"] and retail_dict["Periods"] == date:
                    mail_revenue_month = retail_dict["Index revenue"] 
            for retail_dict in english_retail_data:
                date = datetime(year=(y-1), month=(m), day=1, hour=0, minute=0)
                if "Postorderbedrijven" in retail_dict["Industry"] and retail_dict["Periods"] == date:
                    mail_revenue_month_lastyear = retail_dict["Index revenue"]
            mail_onemonth_yoy = round(((mail_revenue_month/mail_revenue_month_lastyear)*100), 2)
            mail_order_yoy.append(mail_onemonth_yoy)
            m = m + 1
        y = y + 1
        m = 1
    return mail_order_yoy
mail_order_yoy = mail_order_yoy(english_retail_data)

try:
    fig, ax = plt.subplots(figsize=(16, 9))
    ax.plot(months[12:], clothing_stores_yoy, label="Clothing stores' YoY")
    ax.plot(months[12:], mail_order_yoy, label="Mail order companies' YoY")
    ax.set_xlabel('Date')
    ax.set_ylabel('YoY change, 2015=100')
    ax.legend()
    plt.show()
except Exception as e:
    print('There was an error creating the plot.\n'
          'Check if your lists are correctly named and assembled.\n'
          "Here's your error, for your debugging pleasure.")
    raise e

"""**11. In the code cell below, find the best and worst months for both branches of the retail sector in terms of year-over-year revenue change. Print the branch, month and YoY in a nice and tidy way.**"""

#best month clothing
index_max_clothing_stores_yoy = clothing_stores_yoy.index(max(sorted(clothing_stores_yoy)))
month_max_clothing_yoy = months[index_max_clothing_stores_yoy]
print(f'The best month for the clothing stores branche is: {month_max_clothing_yoy.strftime("%Y-%m")} with a year-over-year revenue of: {max(sorted(clothing_stores_yoy))}')

#worst month clothing
index_min_clothing_stores_yoy = clothing_stores_yoy.index(min(sorted(clothing_stores_yoy)))
month_min_clothing_yoy = months[index_min_clothing_stores_yoy]
print(f'The worst month for the clothing stores branche is: {month_min_clothing_yoy.strftime("%Y-%m")} with a year-over-year revenue of: {min(sorted(clothing_stores_yoy))}')

#best month mail
index_max_mail_order_yoy = mail_order_yoy.index(max(sorted(mail_order_yoy)))
month_max_mail_order_yoy = months[index_max_mail_order_yoy]
print(f'The best month for the mail order branche is: {month_max_mail_order_yoy.strftime("%Y-%m")} with a year-over-year revenue of: {max(sorted(mail_order_yoy))}')

#worst month mail
index_min_mail_order_yoy = mail_order_yoy.index(min(sorted(mail_order_yoy)))
month_min_mail_order_yoy = months[index_min_mail_order_yoy]
print(f'The worst month for the mail order branche is: {month_min_mail_order_yoy.strftime("%Y-%m")} with a year-over-year revenue of: {min(sorted(mail_order_yoy))}')

"""### 3.2 Similarity Between Branches

We've seen that the pattern for revenue is quite different for clothing stores and mail order companies. In other words: their revenues don't move up or down together. A way to make this observation more specific is to compute the **correlation coefficient**. It is a number between $-1$ and $1$ that describes the relation between two *random variables*. Here is how it works applied to our revenue numbers:

- If the correlation coefficient for the revenue of two branches of the retail sector is $1$, their revenue is *positively correlated*. This means that when the revenue of branch A goes up, the revenue of branch B also goes up. In other words: the revenues for both branches go up together.
- If the correlation coefficient is $-1$, the revenues of the two branches are *negatively correlated*. This means that if A's revenue goes up, B's revenue goes down. Similarly, if B's revenue goes up, A's revenue goes down. They move in the exact opposite direction.
- If the correlation coefficient is $0$, there is no clear pattern between the revenues of both branches.

Here's a table that summarizes this information:

| Correlation coefficient | Meaning                              |
|-------------------------|--------------------------------------|
| $1$                     | Revenues go up together              |
| $0$                     | No pattern                           |
| $-1$                    | Revenues move in opposite directions |

Note that there is a continuous scale between $-1$ and $1$! A correlation coefficient of $0.3$ indicates a somewhat positively correlated relationship.

And here's an image that visualizes the correlation coefficient.

<img src="https://upload.wikimedia.org/wikipedia/commons/d/d4/Correlation_examples2.svg"/>

We've provided a function `corrcoef` that computes the correlation coefficient for two lists.

**11. In the code cell below, use the function `corrcoef` to compute the correlation coefficient for each pair of branches in our dataset. Then print a sorted table that shows each unique pair and their correlation coefficients. You can take inspiration from this table (but it doesn't have to look exactly like it):**

```
Coeff   Branch A                                          Branch B                                          
===========================================================================================================
0.98    4711, 472 Winkels in voedingsmiddelen             4711 Supermarkten                                 
0.91    475 Winkels in overige huishoudwaren              4752 Winkels in doe-het-zelfartikelen             
0.91    47528 Bouwmarkten                                 4752 Winkels in doe-het-zelfartikelen               
```
"""

import numpy as np

# Provided function. Use this to obtain the correlation coefficient for two lists.
def corrcoef(branch_a, branch_b):
    return np.corrcoef(branch_a, branch_b)[0, 1]

#list with unique branches
unique_branches_list = (unique_branches(english_retail_data))

#list with all combinations of branches in pairs
all_combinations = list(itertools.combinations(unique_branches_list, 2))

def dict_all_revenues (english_retail_data):
    x = 0
    dict_all_revenues = {}
    while x < (len(unique_branches_list)):
        revenue_list = []
        for retail_dict in english_retail_data:
            
            branche_name = unique_branches_list[x]
            if retail_dict["Industry"] == branche_name:
                revenue = retail_dict["Index revenue"]
                revenue_list.append(revenue)
        dict_all_revenues[branche_name] = revenue_list
        x = x +1
    return dict_all_revenues
dict_all_revenues = (dict_all_revenues (english_retail_data))

def corrcoeff_list (all_combinations):
    corrcoef_list = []
    for pair in all_combinations:
        branche_a = dict_all_revenues[pair[0]]
        branche_b = dict_all_revenues[pair[1]]
        corrcoef_calculated = round(corrcoef(branche_a, branche_b), 3)
        corrcoef_list.append([corrcoef_calculated, pair[0], pair[1]])
    return corrcoef_list

corrcoeff_list = corrcoeff_list (all_combinations)


print(tabulate(corrcoeff_list, headers=["Coeff","Branche A", "Branche B"]))

"""**12. Pick two correlation coefficients from the table you created and explain why you think these values are the way that they are. Be sure to pick two coefficients that are not close to each other.**

De correlation coefficients van consumentenelektronica en speelgoedwinkels is 0.618. Dat betekent dat de omzet van beide branches redelijk sterk tegelijkertijd omhoog gaat (of naar beneden). Mijn inschatting is dat de branches redelijk sterk aan elkaar verbonden zijn, door de verkoop van spelcomputers. Als men een nieuwe spelcomputer koopt (consumentenelektronica) dan zal daar ook een bijpassend spel (speelgoedwinkels) bij gekocht worden. Of bij de spellen die in de speelgoedwinkel gekocht worden, zal de consument nog bijpassend elektronica kopen.
De correlation coefficients van Postorderbedrijven/webwinkels en supermarkten is 0.869. Dat betekent dat de omzet van beide branches redelijk sterk tegelijkertijd omhoog gaat (of naar beneden). Mijn inschatting is dat een groot deel van de consumenten online boodschappen besteld. Als men dus meer gaat consumeren in de 'supermarkt', zal dat grotendeels terug te zien zijn in de online aankopen. Hetzelfde wanneer er minder aangeschaft wordt van de supermarkt, dan zal er ook minder online besteld worden.


**13. Imagine you are a very risk-averse investor shaping your portfolio of investments in the retail sector. How would you use the information in the table you created to minimize your investment risk? Which two branches of the retail sector would you invest in if you had to pick two? Use the correlation coefficient in your answer.**

Ik zou twee branches kiezen die praktisch nul invloed hebben op elkaar. We zijn dan dus op zoek naar twee branches waarvan die correlation coefficient 0 nadert, maar wel een ander 'soort' zijn (dus niet voedingsmiddelen en supermarkten). 
Grof gezegd: mocht het slecht gaan met de ene branche, heb je als investeerder altijd nog de andere branche waarop je kan leunen. Bijvoorbeeld: Winkels in recreatieartikelen en Drogisterijen, met correlation coefficient van 0.01. Dit zijn twee zeer verschillende branches, waardoor de investeerder goed zijn kansen spreidt, en zo min mogelijk risico loopt.

## 4. Conclusion

You made it! This was the Retail assignment. Before you hand it in: restart the kernel and run all the cells. Then save it to GitHub and share the link with us in the usual way.
"""